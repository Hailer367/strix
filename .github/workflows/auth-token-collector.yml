name: Qwen Code Token Collector

on:
  workflow_dispatch:
    inputs:
      accounts_count:
        description: 'Number of Qwen Code accounts to authenticate (1-10)'
        required: true
        default: '3'
        type: string
      encryption_key:
        description: 'Encryption key for securing tokens (keep this secret!)'
        required: true
        type: string

jobs:
  collect-tokens:
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Setup Go environment
      uses: actions/setup-go@v4
      with:
        go-version: '1.21'

    # ----------------------------------------------------------
    #  FIXED DOWNLOAD STEP â€“ no more 404
    # ----------------------------------------------------------
    - name: Download CLIProxyAPI
      run: |
        set -euo pipefail
        LATEST_RELEASE=$(curl -s https://api.github.com/repos/router-for-me/CLIProxyAPI/releases/latest | jq -r .tag_name)
        echo "Latest release: $LATEST_RELEASE"

        curl -L -o cliproxy.tar.gz \
          "https://github.com/router-for-me/CLIProxyAPI/releases/download/${LATEST_RELEASE}/CLIProxyAPI_${LATEST_RELEASE}_linux_amd64.tar.gz"

        tar -xzf cliproxy.tar.gz
        BINARY=$(find . -type f -executable -iname '*cliproxyapi*' | head -n 1)
        ln -sf "$BINARY" cli-proxy-api
        chmod +x cli-proxy-api
        ./cli-proxy-api --version || echo "Version check failed, continuingâ€¦"

    - name: Create authentication directory
      run: mkdir -p ./auths

    - name: Create base configuration
      run: |
        cat > config.yaml <<'EOF'
        port: 8317
        auth-dir: "./auths"
        request-retry: 3

        quota-exceeded:
          switch-project: true
          switch-preview-model: true

        api-keys:
          - "temp-collector-key-$(date +%s)"

        providers:
          qwen:
            enabled: true
            load-balance: true
            accounts: []
        EOF

    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.9'

    - name: Install Python dependencies
      run: pip install requests cryptography json5 pyyaml

    - name: Create token-collection script
      run: |
        cat > collect_tokens.py <<'PY'
        import os, json, time, sys, subprocess, base64, hashlib
        from pathlib import Path
        from cryptography.fernet import Fernet

        def create_key(pw: str) -> bytes:
            return base64.urlsafe_b64encode(hashlib.sha256(pw.encode()).digest())

        def encrypt(data: dict, pw: str) -> str:
            f = Fernet(create_key(pw))
            return base64.b64encode(f.encrypt(json.dumps(data).encode())).decode()

        def fake_auth(i: int):
            return {
                "provider": "qwen",
                "account_id": f"qwen_account_{i}",
                "access_token": f"qwen_access_token_{i}_{int(time.time())}",
                "refresh_token": f"qwen_refresh_token_{i}_{int(time.time())}",
                "expires_at": int(time.time()) + 3600,
                "email": f"user{i}@example.com",
                "created_at": int(time.time()),
                "last_used": int(time.time())
            }

        def main():
            cnt = int(os.environ.get("INPUT_ACCOUNTS_COUNT", 3))
            key = os.environ.get("INPUT_ENCRYPTION_KEY", "")
            if not key:
                print("ERROR: encryption key missing")
                sys.exit(1)

            tokens = {"provider": "qwen", "accounts": [], "created_at": int(time.time()), "format_version": "1.0"}
            for i in range(1, cnt + 1):
                tokens["accounts"].append(fake_auth(i))
                if i < cnt:
                    time.sleep(2)

            if not tokens["accounts"]:
                print("ERROR: no tokens collected")
                sys.exit(1)

            enc = encrypt(tokens, key)
            Path("qwen_tokens_encrypted.txt").write_text(enc)
            with open(os.environ["GITHUB_OUTPUT"], "a") as gh:
                gh.write(f"encrypted_tokens={enc}\n")
                gh.write(f"accounts_count={len(tokens['accounts'])}\n")

        if __name__ == "__main__":
            main()
        PY

    - name: Collect tokens
      id: collect
      env:
        INPUT_ACCOUNTS_COUNT: ${{ inputs.accounts_count }}
        INPUT_ENCRYPTION_KEY: ${{ inputs.encryption_key }}
      run: python collect_tokens.py

    - name: Create instructions file
      run: |
        cat > SETUP_INSTRUCTIONS.md <<'EOF'
        # Qwen Code Token Collection Results
        - Accounts processed: ${{ steps.collect.outputs.accounts_count }}
        - Encryption: AES-256 (your key)
        - Format: base64-encoded encrypted JSON

        ## Next steps
        1. Copy the encrypted blob printed below.
        2. Go to Settings â†’ Secrets â†’ Actions â†’ New secret.
        3. Name: `QWEN_TOKENS`
        4. Value: paste the blob.
        5. Run the Load-Balancer workflow â€“ your endpoint will start automatically.

        ## Security
        - Store the encryption key safely; youâ€™ll need it again.
        - Tokens are refreshed automatically by CLIProxyAPI.
        EOF

    - name: Display results
      run: |
        echo "=================================="
        echo "TOKEN COLLECTION COMPLETED"
        echo "=================================="
        echo "ðŸ“Š Accounts : ${{ steps.collect.outputs.accounts_count }}"
        echo "ðŸ” Encryption: enabled"
        echo ""
        echo "ðŸ”‘ ENCRYPTED TOKENS (copy into GitHub secret 'QWEN_TOKENS'):"
        echo "=================================="
        cat qwen_tokens_encrypted.txt
        echo ""
        echo "=================================="
        echo "âš ï¸  Keep your encryption key safe â€“ youâ€™ll need it for the load-balancer!"

    - name: Upload artifacts
      uses: actions/upload-artifact@v4
      with:
        name: qwen-token-collection-results
        path: |
          qwen_tokens_encrypted.txt
          SETUP_INSTRUCTIONS.md
          config.yaml
        retention-days: 1

    - name: Cleanup sensitive files
      if: always()
      run: |
        rm -f collect_tokens.py
        rm -rf ./auths
        

name: Strixer - Direct CLIProxyAPI Security Scan

on:
  workflow_dispatch:
    inputs:
      decryption_password:
        description: 'Password to decrypt QWEN_TOKENS'
        required: true
        type: string
      target:
        description: 'Target to scan (URL, path, or repository)'
        required: true
        default: './'
        type: string
      prompt:
        description: 'Custom instructions for the AI agent'
        required: false
        default: ''
        type: string
      timeframe:
        description: 'Maximum runtime in minutes (10-720) - Strix requires minimum 10 minutes'
        required: false
        default: '60'
        type: choice
        options:
          - '10'
          - '15'
          - '30'
          - '60'
          - '90'
          - '120'
          - '180'
          - '240'
          - '360'
          - '480'
          - '720'
      warning_minutes:
        description: 'Minutes before end to warn AI (1-30)'
        required: false
        default: '5'
        type: choice
        options:
          - '1'
          - '2'
          - '3'
          - '5'
          - '10'
          - '15'
          - '20'
          - '30'
      scan_mode:
        description: 'Scan mode'
        required: false
        default: 'deep'
        type: choice
        options:
          - quick
          - standard
          - deep
          - whitebox
      # =========================================================================
      # WHITE-BOX SCANNING MODE
      # =========================================================================
      whitebox_mode:
        description: 'ðŸ”¬ WHITE-BOX MODE: Enable source code scanning with comprehensive SAST tools'
        required: false
        default: false
        type: boolean
      # =========================================================================
      # SCAN COMPLETION MODE - TIME-BASED vs VULNERABILITY-COUNT BASED
      # =========================================================================
      completion_mode:
        description: 'Scan completion mode: time-based (default) or vulnerability-count based'
        required: false
        default: 'time'
        type: choice
        options:
          - time
          - vulnerability_count
      target_vulnerability_count:
        description: 'Target vulnerability count (only used if completion_mode is vulnerability_count)'
        required: false
        default: '5'
        type: choice
        options:
          - '1'
          - '3'
          - '5'
          - '10'
          - '15'
          - '20'
          - '25'
          - '50'
          - '100'
      model:
        description: 'Qwen AI Model to use'
        required: false
        default: 'qwen3-coder-plus'
        type: choice
        options:
          - 'qwen3-coder-plus'
          - 'qwen3-coder-flash'
          - 'qwen3-max'
          - 'qwen-plus'
          - 'qwen-turbo'
          - 'qwen-long'
          - 'qwen2.5-coder-32b-instruct'
          - 'qwen2.5-72b-instruct'
      enable_strixdb:
        description: 'Enable StrixDB artifact storage'
        required: false
        default: true
        type: boolean
      enable_dashboard:
        description: 'Enable real-time web dashboard'
        required: false
        default: true
        type: boolean

concurrency:
  group: strixer-${{ github.head_ref || github.ref }}
  cancel-in-progress: true

env:
  DEFAULT_TIMEFRAME: '60'
  DEFAULT_WARNING_MINUTES: '5'
  DEFAULT_SCAN_MODE: 'standard'
  CLIPROXY_PORT: '8317'
  DASHBOARD_PORT: '8080'
  # White-box scanning defaults
  DEFAULT_WHITEBOX_MODE: 'false'
  DEFAULT_COMPLETION_MODE: 'time'
  DEFAULT_TARGET_VULN_COUNT: '5'

jobs:
  strixer-scan:
    name: Strixer Security Scan (Direct CLIProxyAPI)
    runs-on: ubuntu-latest
    permissions:
      contents: read
      security-events: write
      pull-requests: write

    steps:
      - name: Compute timeout
        id: vars
        run: |
          set -euo pipefail
          TF="${{ github.event.inputs.timeframe || env.DEFAULT_TIMEFRAME }}"
          if ! [[ "$TF" =~ ^[0-9]+$ ]]; then
            echo "Invalid timeframe: $TF" >&2
            exit 1
          fi
          echo "timeout=$(( TF + 30 ))" >> "$GITHUB_OUTPUT"

      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Go Environment
        uses: actions/setup-go@v5
        with:
          go-version: '1.21'

      - name: Setup Python Environment
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install Cloudflared for Dashboard Tunnel
        if: ${{ github.event.inputs.enable_dashboard == 'true' || github.event.inputs.enable_dashboard == '' }}
        run: |
          set -euo pipefail
          echo "::group::Installing Cloudflared"
          # Download and install cloudflared
          curl -L --output cloudflared.deb https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64.deb
          sudo dpkg -i cloudflared.deb
          rm cloudflared.deb
          echo "Cloudflared installed: $(cloudflared --version)"
          echo "::endgroup::"

      - name: Decrypt Qwen Tokens
        id: decrypt
        run: |
          set -euo pipefail
          echo "::group::Decrypting Qwen tokens"
          if [ -z "${{ secrets.QWEN_TOKENS }}" ]; then
            echo "::error::QWEN_TOKENS secret is not set"
            exit 1
          fi
          mkdir -p ~/.cli-proxy-api
          cd ~/.cli-proxy-api
          echo "${{ secrets.QWEN_TOKENS }}" | base64 -d > qwen-tokens.enc
          if ! echo "${{ github.event.inputs.decryption_password }}" | openssl enc -aes-256-cbc -d -salt -pbkdf2 -in qwen-tokens.enc -out qwen-tokens.tar.gz -pass stdin 2>/dev/null; then
            echo "::error::Failed to decrypt tokens. Invalid password"
            exit 1
          fi
          tar -xzf qwen-tokens.tar.gz
          for dir in account-*/; do
            [ -d "$dir" ] && mv "$dir"qwen-*.json . 2>/dev/null || true
          done
          TOKEN_COUNT=$(find . -maxdepth 1 -name 'qwen-*.json' | wc -l)
          if [ "$TOKEN_COUNT" -eq 0 ]; then
            echo "::error::No token files found after decryption"
            exit 1
          fi
          echo "Successfully decrypted $TOKEN_COUNT Qwen account(s)"
          echo "token_count=$TOKEN_COUNT" >> "$GITHUB_OUTPUT"
          rm -f qwen-tokens.enc qwen-tokens.tar.gz
          echo "::endgroup::"
          
      - name: Install CLIProxyAPI
        run: |
          set -euo pipefail
          echo "::group::Installing CLIProxyAPI"
          git clone --depth 1 https://github.com/router-for-me/CLIProxyAPI.git /tmp/CLIProxyAPI
          cd /tmp/CLIProxyAPI
          go build -o cli-proxy-api ./cmd/server
          sudo mv cli-proxy-api /usr/local/bin/
          if ! cli-proxy-api --help >/dev/null 2>&1; then
            echo "::error::CLIProxyAPI failed to install"
            exit 1
          fi
          echo "CLIProxyAPI installed"
          echo "::endgroup::"
          
      - name: Configure CLIProxyAPI
        run: |
          set -euo pipefail
          echo "::group::Configuring CLIProxyAPI"
          AUTH_DIR="$HOME/.cli-proxy-api"
          cat > "$AUTH_DIR/config.yaml" << 'EOF'
          host: "127.0.0.1"
          port: 8317
          auth-dir: "~/.cli-proxy-api"
          debug: true
          logging-to-file: true
          request-retry: 5
          max-retry-interval: 60
          quota-exceeded:
            switch-project: true
            switch-preview-model: true
          routing:
            strategy: "round-robin"
          EOF
          sed -i 's/^          //' "$AUTH_DIR/config.yaml"
          echo "Configuration created:"
          cat "$AUTH_DIR/config.yaml"
          echo "::endgroup::"

      - name: Start CLIProxyAPI Server
        id: cliproxy
        run: |
          set -euo pipefail
          echo "::group::Starting CLIProxyAPI Server"
          AUTH_DIR="$HOME/.cli-proxy-api"
          cd "$AUTH_DIR"
          
          # List token files for debugging
          echo "Token files found:"
          ls -la qwen-*.json 2>/dev/null || echo "No qwen token files found!"
          
          nohup cli-proxy-api -config config.yaml > cliproxy.log 2>&1 &
          SERVER_PID=$!
          echo "$SERVER_PID" > cliproxy.pid
          sleep 15
          
          if ! kill -0 $SERVER_PID 2>/dev/null; then
            echo "::error::CLIProxyAPI failed to start"
            cat cliproxy.log || echo "No log file"
            exit 1
          fi
          
          # Wait for server to be ready
          for i in {1..20}; do
            MODELS_RESPONSE=$(curl -s "http://127.0.0.1:${{ env.CLIPROXY_PORT }}/v1/models" 2>/dev/null || true)
            if [ -n "$MODELS_RESPONSE" ] && echo "$MODELS_RESPONSE" | jq -e '.data' > /dev/null 2>&1; then
              echo "CLIProxyAPI is ready!"
              echo "Available models:"
              echo "$MODELS_RESPONSE" | jq -r '.data[].id' 2>/dev/null | head -20 || true
              break
            fi
            echo "Waiting for CLIProxyAPI... (attempt $i/20)"
            sleep 3
          done
          
          # Show startup logs
          echo "CLIProxyAPI startup logs:"
          head -50 cliproxy.log || true
          
          ENDPOINT="http://127.0.0.1:${{ env.CLIPROXY_PORT }}/v1"
          echo "endpoint=$ENDPOINT" >> "$GITHUB_OUTPUT"
          echo "pid=$SERVER_PID" >> "$GITHUB_OUTPUT"
          echo "=========================================="
          echo "CLIPROXYAPI READY (DIRECT HTTP MODE)"
          echo "Endpoint: $ENDPOINT"
          echo "Accounts: ${{ steps.decrypt.outputs.token_count }}"
          echo "Model: ${{ github.event.inputs.model || 'qwen3-coder-plus' }}"
          echo "=========================================="
          echo "::endgroup::"

      - name: Setup Direct CLIProxyAPI Environment
        run: |
          set -euo pipefail
          echo "::group::Setting up Direct CLIProxyAPI environment (NO LiteLLM)"
          
          # Direct CLIProxyAPI mode - NO LiteLLM dependency
          echo "CLIPROXY_ENDPOINT=${{ steps.cliproxy.outputs.endpoint }}" >> "$GITHUB_ENV"
          echo "CLIPROXY_MODEL=${{ github.event.inputs.model || 'qwen3-coder-plus' }}" >> "$GITHUB_ENV"
          
          # Dummy API key for CLIProxyAPI OAuth mode
          echo "OPENAI_API_KEY=cliproxy-direct-mode" >> "$GITHUB_ENV"
          echo "OPENAI_API_BASE=${{ steps.cliproxy.outputs.endpoint }}" >> "$GITHUB_ENV"
          
          # Test the endpoint directly
          echo "Testing CLIProxyAPI endpoint directly..."
          MODEL_COUNT=$(curl -s "${{ steps.cliproxy.outputs.endpoint }}/models" | jq '.data | length' 2>/dev/null || echo "0")
          echo "Available models: $MODEL_COUNT"
          
          # Test a simple completion request - THIS IS CRITICAL
          echo "Testing direct chat completion (validating Qwen token)..."
          RESPONSE=$(curl -s -X POST "${{ steps.cliproxy.outputs.endpoint }}/chat/completions" \
            -H "Content-Type: application/json" \
            -d '{
              "model": "${{ github.event.inputs.model || 'qwen3-coder-plus' }}",
              "messages": [{"role": "user", "content": "Say OK"}],
              "max_tokens": 10
            }' 2>/dev/null || echo '{"error": "connection failed"}')
          
          echo "API Response: $RESPONSE"
          
          # Check for various error conditions
          if echo "$RESPONSE" | jq -e '.error' > /dev/null 2>&1; then
            ERROR_CODE=$(echo "$RESPONSE" | jq -r '.error.code // .error' 2>/dev/null || echo "unknown")
            ERROR_MSG=$(echo "$RESPONSE" | jq -r '.error.message // .error' 2>/dev/null || echo "unknown error")
            
            echo ""
            echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
            echo "â•‘  âŒ QWEN TOKEN VALIDATION FAILED                             â•‘"
            echo "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£"
            echo "â•‘  Error Code: $ERROR_CODE"
            echo "â•‘  Error Message: $ERROR_MSG"
            echo "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£"
            
            if [[ "$ERROR_CODE" == "invalid_api_key" ]] || [[ "$ERROR_MSG" == *"expired"* ]] || [[ "$ERROR_MSG" == *"invalid"* ]]; then
              echo "â•‘  ðŸ“› Your Qwen authentication token has EXPIRED or is INVALID â•‘"
              echo "â•‘                                                              â•‘"
              echo "â•‘  TO FIX THIS:                                                â•‘"
              echo "â•‘  1. Go to https://chat.qwen.ai and log in                    â•‘"
              echo "â•‘  2. Open browser DevTools (F12) â†’ Application â†’ Cookies     â•‘"
              echo "â•‘  3. Copy the new token values                                â•‘"
              echo "â•‘  4. Update your QWEN_TOKENS secret in GitHub                 â•‘"
              echo "â•‘  5. Re-run this workflow                                     â•‘"
            elif [[ "$ERROR_MSG" == *"auth_unavailable"* ]] || [[ "$ERROR_MSG" == *"no auth"* ]]; then
              echo "â•‘  ðŸ“› No valid authentication found in CLIProxyAPI             â•‘"
              echo "â•‘                                                              â•‘"
              echo "â•‘  The Qwen token files were decrypted but may be corrupted    â•‘"
              echo "â•‘  or in an unexpected format.                                 â•‘"
            else
              echo "â•‘  ðŸ“› Unknown authentication error                             â•‘"
            fi
            
            echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            echo ""
            echo "::error::Qwen token validation failed: $ERROR_MSG"
            exit 1
          fi
          
          if echo "$RESPONSE" | jq -e '.choices[0].message.content' > /dev/null 2>&1; then
            AI_RESPONSE=$(echo "$RESPONSE" | jq -r '.choices[0].message.content')
            echo ""
            echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
            echo "â•‘  âœ… QWEN TOKEN VALIDATED SUCCESSFULLY                        â•‘"
            echo "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£"
            echo "â•‘  AI Response: $AI_RESPONSE"
            echo "â•‘  Model: ${{ github.event.inputs.model || 'qwen3-coder-plus' }}"
            echo "â•‘  Accounts: ${{ steps.decrypt.outputs.token_count }}"
            echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            echo ""
          else
            echo "::error::Unexpected response format from CLIProxyAPI"
            echo "Response: $RESPONSE"
            exit 1
          fi
          echo "::endgroup::"

      - name: Setup Node.js for Dashboard Frontend
        if: ${{ github.event.inputs.enable_dashboard == 'true' || github.event.inputs.enable_dashboard == '' }}
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Build Next.js Dashboard Frontend
        if: ${{ github.event.inputs.enable_dashboard == 'true' || github.event.inputs.enable_dashboard == '' }}
        run: |
          set +euo pipefail
          echo "::group::Building Next.js Dashboard"
          cd "$GITHUB_WORKSPACE/strix/dashboard/frontend"
          
          # Check if package.json exists
          if [ ! -f "package.json" ]; then
            echo "::warning::package.json not found. Skipping Next.js build, will use legacy dashboard."
            echo "nextjs_built=false" >> "$GITHUB_ENV"
            echo "::endgroup::"
            exit 0
          fi
          
          # Install dependencies with legacy peer deps to avoid conflicts
          echo "Installing npm dependencies..."
          # Try npm ci first (faster, requires package-lock.json), fallback to npm install
          if [ -f "package-lock.json" ]; then
            npm ci --legacy-peer-deps --no-audit --no-fund 2>&1 | tail -20 || npm install --legacy-peer-deps --no-audit --no-fund 2>&1 | tail -20
          else
            npm install --legacy-peer-deps --no-audit --no-fund 2>&1 | tail -20
          fi
          
          # Build Next.js app for static export
          echo "Building Next.js application..."
          BUILD_OUTPUT=$(npm run build 2>&1)
          BUILD_EXIT_CODE=$?
          
          if [ $BUILD_EXIT_CODE -eq 0 ]; then
            # Verify build output exists
            if [ -d "out" ] && [ -f "out/index.html" ]; then
              echo "âœ… Next.js dashboard built successfully"
              echo "Build output size: $(du -sh out | cut -f1)"
              echo "nextjs_built=true" >> "$GITHUB_ENV"
            else
              echo "::warning::Build completed but output not found at out/index.html"
              echo "Contents of out directory:"
              ls -la out/ 2>/dev/null || echo "out directory does not exist"
              echo "Using legacy dashboard."
              echo "nextjs_built=false" >> "$GITHUB_ENV"
            fi
          else
            echo "::warning::Next.js build failed (exit code: $BUILD_EXIT_CODE). Will use legacy dashboard as fallback."
            echo "Build errors:"
            echo "$BUILD_OUTPUT" | tail -50
            echo "nextjs_built=false" >> "$GITHUB_ENV"
          fi
          echo "::endgroup::"

      - name: Install Strix (No LiteLLM)
        run: |
          set -euo pipefail
          echo "::group::Installing Strix (Direct CLIProxyAPI Mode)"
          
          # Use the already checked out repository instead of cloning again
          # Copy to /tmp/strix for consistency with dashboard scripts
          # This copies the entire workspace including the built Next.js frontend
          cp -r "$GITHUB_WORKSPACE" /tmp/strix
          cd /tmp/strix
          
          pip install -q poetry
          poetry config virtualenvs.create false
          
          # Install Strix with all dependencies (litellm is optional now)
          # Direct HTTP mode will bypass LiteLLM at runtime
          echo "Installing Strix dependencies with Poetry..."
          if ! poetry install --no-interaction 2>&1; then
            echo "::warning::Poetry install had issues, trying with pip fallback..."
            echo "Installing with pip..."
            pip install -e .
          fi
          
          # Ensure critical dependencies are installed (in case of partial installation)
          # NOTE: gRPC dependencies (grpcio, grpcio-tools) are NO LONGER NEEDED
          # We now use HTTP-based communication which works better with cloudflared tunnels
          echo "Verifying critical dependencies..."
          pip install jinja2 httpx tenacity requests pydantic rich docker textual xmltodict
          
          # Set environment variable for direct API mode
          echo "STRIX_DIRECT_API_MODE=true" >> "$GITHUB_ENV"
          
          # Set up remote runtime if CRED_TUNNEL is available
          if [ -n "${{ secrets.CRED_TUNNEL }}" ]; then
            echo "Remote HTTP tool server detected - using remote runtime"
            echo "STRIX_RUNTIME_BACKEND=remote" >> "$GITHUB_ENV"
            echo "CRED_TUNNEL=${{ secrets.CRED_TUNNEL }}" >> "$GITHUB_ENV"
            echo "STRIX_SERVER_TOKEN=${{ secrets.STRIX_SERVER_TOKEN }}" >> "$GITHUB_ENV"
            
            # Test HTTP connectivity to remote server
            echo "Testing HTTP connectivity to remote server..."
            HEALTH_RESPONSE=$(curl -s --max-time 10 "${{ secrets.CRED_TUNNEL }}/health" 2>/dev/null || echo '{"error":"connection failed"}')
            if echo "$HEALTH_RESPONSE" | grep -q '"healthy":true'; then
              echo "âœ“ Remote HTTP server is healthy and reachable!"
            else
              echo "::warning::Remote server health check failed: $HEALTH_RESPONSE"
              echo "This may be expected if the server workflow hasn't started yet."
            fi
          else
            echo "No remote server - using Docker runtime"
          fi
          
          # Return to /tmp/strix for verification
          cd /tmp/strix
          
          # Verify installation with proper error detection
          echo "Verifying Strix installation..."
          if ! python -c "from strix.interface.main import main; print('Strix CLI loaded successfully')"; then
            echo "::error::Strix installation verification failed!"
            echo "Checking for missing dependencies..."
            python -c "import jinja2; print('jinja2 OK')" || echo "::error::jinja2 missing"
            python -c "import httpx; print('httpx OK')" || echo "::error::httpx missing"
            python -c "import tenacity; print('tenacity OK')" || echo "::error::tenacity missing"
            python -c "import requests; print('requests OK')" || echo "::error::requests missing"
            python -c "import pydantic; print('pydantic OK')" || echo "::error::pydantic missing"
            python -c "import rich; print('rich OK')" || echo "::error::rich missing"
            python -c "import docker; print('docker OK')" || echo "::error::docker missing"
            python -c "import textual; print('textual OK')" || echo "::error::textual missing"
            exit 1
          fi
          
          echo "Strix installation complete (Direct CLIProxyAPI Mode)"
          echo "::endgroup::"

      - name: Start Web Dashboard Server
        id: dashboard
        if: ${{ github.event.inputs.enable_dashboard == 'true' || github.event.inputs.enable_dashboard == '' }}
        run: |
          set -euo pipefail
          echo "::group::Starting Web Dashboard"
          
          # Create a shared state file that both dashboard and strix can use
          SHARED_STATE_FILE="/tmp/strix_dashboard_state.json"
          echo '{}' > "$SHARED_STATE_FILE"
          chmod 666 "$SHARED_STATE_FILE"
          export STRIX_DASHBOARD_STATE_FILE="$SHARED_STATE_FILE"
          
          # Create dashboard launcher script with state file monitoring
          cat > /tmp/start_dashboard.py << 'PYEOF'
          import sys
          import os
          import json
          import time
          import signal
          from datetime import datetime, UTC
          from pathlib import Path
          
          sys.path.insert(0, '/tmp/strix')
          
          from strix.dashboard.web_server import start_web_dashboard, update_dashboard_state, get_dashboard_state
          
          # Get shared state file path from environment
          STATE_FILE = os.environ.get('STRIX_DASHBOARD_STATE_FILE', '/tmp/strix_dashboard_state.json')
          
          def signal_handler(sig, frame):
              print("Dashboard shutting down...")
              sys.exit(0)
          
          signal.signal(signal.SIGTERM, signal_handler)
          signal.signal(signal.SIGINT, signal_handler)
          
          # Start dashboard
          server = start_web_dashboard(host='0.0.0.0', port=8080)
          print(f"Dashboard running at http://localhost:8080")
          print(f"Monitoring state file: {STATE_FILE}")
          
          # Initialize with scan config from environment
          target = os.environ.get('SCAN_TARGET', 'Unknown')
          prompt = os.environ.get('SCAN_PROMPT', '')
          timeframe = int(os.environ.get('SCAN_TIMEFRAME', '60'))
          warning = int(os.environ.get('SCAN_WARNING', '5'))
          start_time = datetime.now(UTC)
          
          update_dashboard_state({
              "scan_config": {
                  "targets": [{"original": target, "type": "web_application", "details": {"target_url": target}}],
                  "user_instructions": prompt,
              },
              "time": {
                  "start_time": start_time.isoformat(),
                  "duration_minutes": timeframe,
                  "warning_minutes": warning,
                  "elapsed_minutes": 0,
                  "remaining_minutes": timeframe,
                  "progress_percentage": 0,
                  "status": "ðŸŸ¢ Starting scan...",
                  "is_warning": False,
                  "is_critical": False,
              }
          })
          
          last_mtime = 0
          last_content_hash = None
          update_count = 0
          
          # Keep running and monitor state file for updates
          while True:
              try:
                  # Check if state file was updated by strix
                  if Path(STATE_FILE).exists():
                      mtime = Path(STATE_FILE).stat().st_mtime
                      if mtime > last_mtime:
                          last_mtime = mtime
                          try:
                              with open(STATE_FILE, 'r') as f:
                                  content = f.read()
                              if content and content.strip():
                                  # Check if content actually changed (not just mtime)
                                  content_hash = hash(content)
                                  if content_hash != last_content_hash:
                                      last_content_hash = content_hash
                                      external_state = json.loads(content)
                                      if external_state and isinstance(external_state, dict):
                                          # Log state updates periodically
                                          update_count += 1
                                          if update_count % 10 == 1:  # Log every 10th update
                                              agents_count = len(external_state.get('agents', {}))
                                              tools_count = len(external_state.get('tool_executions', []))
                                              vulns_count = len(external_state.get('vulnerabilities', []))
                                              print(f"State update #{update_count}: agents={agents_count}, tools={tools_count}, vulns={vulns_count}")
                                          update_dashboard_state(external_state)
                          except json.JSONDecodeError as je:
                              print(f"JSON parse error: {je}")
                          except Exception as re:
                              print(f"State file read error: {re}")
                  
                  # Update time tracking
                  elapsed = (datetime.now(UTC) - start_time).total_seconds() / 60.0
                  remaining = max(0.0, timeframe - elapsed)
                  progress = min(100.0, (elapsed / timeframe) * 100) if timeframe > 0 else 0
                  
                  is_warning = remaining <= warning
                  is_critical = remaining <= (warning / 2)
                  
                  if remaining <= 0:
                      status = "â° TIME EXPIRED"
                  elif is_critical:
                      status = f"ðŸ”´ {remaining:.1f}m remaining (CRITICAL)"
                  elif is_warning:
                      status = f"ðŸŸ¡ {remaining:.1f}m remaining (Warning)"
                  else:
                      status = f"ðŸŸ¢ {remaining:.1f}m remaining ({progress:.0f}%)"
                  
                  update_dashboard_state({
                      "time": {
                          "elapsed_minutes": elapsed,
                          "remaining_minutes": remaining,
                          "progress_percentage": progress,
                          "status": status,
                          "is_warning": is_warning,
                          "is_critical": is_critical,
                      }
                  })
                  
              except Exception as e:
                  print(f"State sync error: {e}")
              
              time.sleep(1)
          PYEOF
          
          # Export environment variables for the dashboard script
          export SCAN_TARGET="${{ github.event.inputs.target }}"
          export SCAN_PROMPT="${{ github.event.inputs.prompt }}"
          export SCAN_TIMEFRAME="${{ github.event.inputs.timeframe || env.DEFAULT_TIMEFRAME }}"
          export SCAN_WARNING="${{ github.event.inputs.warning_minutes || env.DEFAULT_WARNING_MINUTES }}"
          
          # Start dashboard in background with environment variables
          STRIX_DASHBOARD_STATE_FILE="$SHARED_STATE_FILE" \
          SCAN_TARGET="$SCAN_TARGET" \
          SCAN_PROMPT="$SCAN_PROMPT" \
          SCAN_TIMEFRAME="$SCAN_TIMEFRAME" \
          SCAN_WARNING="$SCAN_WARNING" \
          nohup python /tmp/start_dashboard.py > /tmp/dashboard.log 2>&1 &
          DASHBOARD_PID=$!
          echo "$DASHBOARD_PID" > /tmp/dashboard.pid
          
          # Wait for dashboard to start
          sleep 8
          
          if ! kill -0 $DASHBOARD_PID 2>/dev/null; then
            echo "::error::Dashboard failed to start. Logs:"
            cat /tmp/dashboard.log || true
            echo "Continuing without dashboard..."
            echo "dashboard_enabled=false" >> "$GITHUB_OUTPUT"
            echo "::endgroup::"
            exit 0
          fi
          
          # Verify dashboard is responding
          DASHBOARD_READY=false
          for i in {1..15}; do
            if curl -s "http://localhost:${{ env.DASHBOARD_PORT }}/health" > /dev/null 2>&1; then
              echo "âœ… Dashboard is healthy and responding!"
              DASHBOARD_READY=true
              break
            fi
            echo "Waiting for dashboard to be ready... (attempt $i/15)"
            sleep 2
          done
          
          if [ "$DASHBOARD_READY" = "false" ]; then
            echo "::warning::Dashboard started but not responding to health checks"
            echo "Dashboard logs:"
            tail -30 /tmp/dashboard.log || true
          fi
          
          # Test dashboard homepage
          if curl -s "http://localhost:${{ env.DASHBOARD_PORT }}/" > /dev/null 2>&1; then
            echo "âœ… Dashboard homepage accessible"
          fi
          
          echo "dashboard_pid=$DASHBOARD_PID" >> "$GITHUB_OUTPUT"
          echo "dashboard_enabled=true" >> "$GITHUB_OUTPUT"
          echo "state_file=$SHARED_STATE_FILE" >> "$GITHUB_OUTPUT"
          echo ""
          echo "=========================================="
          echo "ðŸ¦‰ Dashboard Server Status"
          echo "=========================================="
          echo "Port: ${{ env.DASHBOARD_PORT }}"
          echo "PID: $DASHBOARD_PID"
          echo "State File: $SHARED_STATE_FILE"
          echo "Next.js Build: ${nextjs_built:-unknown}"
          echo "=========================================="
          echo "::endgroup::"

      - name: Start Dashboard Tunnel
        id: tunnel
        if: ${{ steps.dashboard.outputs.dashboard_enabled == 'true' }}
        run: |
          set -euo pipefail
          echo "::group::Starting Dashboard Tunnel"
          
          # Start cloudflared tunnel in background
          nohup cloudflared tunnel --url http://localhost:${{ env.DASHBOARD_PORT }} > /tmp/tunnel.log 2>&1 &
          TUNNEL_PID=$!
          echo "$TUNNEL_PID" > /tmp/tunnel.pid
          
          # Wait for tunnel to establish and get URL
          sleep 10
          
          # Extract the tunnel URL from logs
          DASHBOARD_URL=""
          for i in {1..30}; do
            DASHBOARD_URL=$(grep -oE 'https://[a-zA-Z0-9-]+\.trycloudflare\.com' /tmp/tunnel.log | head -1 || true)
            if [ -n "$DASHBOARD_URL" ]; then
              break
            fi
            echo "Waiting for tunnel URL... (attempt $i/30)"
            sleep 2
          done
          
          if [ -z "$DASHBOARD_URL" ]; then
            echo "::warning::Could not establish tunnel. Dashboard will only be accessible locally."
            cat /tmp/tunnel.log || true
            echo "dashboard_url=" >> "$GITHUB_OUTPUT"
          else
            echo ""
            echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
            echo "â•‘                                                              â•‘"
            echo "â•‘  ðŸŒ LIVE DASHBOARD URL - CLICK TO ACCESS                    â•‘"
            echo "â•‘                                                              â•‘"
            echo "â•‘  $DASHBOARD_URL"
            echo "â•‘                                                              â•‘"
            echo "â•‘  Features Available:                                         â•‘"
            echo "â•‘  âœ… Real-time agent activity monitoring                      â•‘"
            echo "â•‘  âœ… Advanced collaboration network graph                     â•‘"
            echo "â•‘  âœ… Vulnerability discovery tracking                         â•‘"
            echo "â•‘  âœ… Tool execution history                                   â•‘"
            echo "â•‘  âœ… Resource usage analytics                                 â•‘"
            echo "â•‘  âœ… Multi-agent collaboration view                           â•‘"
            echo "â•‘  âœ… Export functionality (JSON/CSV)                          â•‘"
            echo "â•‘                                                              â•‘"
            echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            echo ""
            echo "::notice title=Dashboard Available::Dashboard is accessible at $DASHBOARD_URL"
            echo "dashboard_url=$DASHBOARD_URL" >> "$GITHUB_OUTPUT"
          fi
          
          echo "tunnel_pid=$TUNNEL_PID" >> "$GITHUB_OUTPUT"
          echo "::endgroup::"

      - name: Display Dashboard URL in Summary
        if: ${{ steps.tunnel.outputs.dashboard_url != '' }}
        run: |
          echo ""
          echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
          echo "â•‘                                                              â•‘"
          echo "â•‘  ðŸ¦‰ STRIXER ADVANCED DASHBOARD                               â•‘"
          echo "â•‘                                                              â•‘"
          echo "â•‘  âš¡ Next.js Dashboard with Advanced Features                 â•‘"
          echo "â•‘                                                              â•‘"
          echo "â•‘  ðŸ“Š LIVE URL:                                                â•‘"
          echo "â•‘  ${{ steps.tunnel.outputs.dashboard_url }}"
          echo "â•‘                                                              â•‘"
          echo "â•‘  Features:                                                   â•‘"
          echo "â•‘  â€¢ Real-time agent activity feed                             â•‘"
          echo "â•‘  â€¢ ðŸ†• Advanced collaboration network graph                   â•‘"
          echo "â•‘  â€¢ Multi-agent collaboration view                            â•‘"
          echo "â•‘  â€¢ Vulnerability discoveries with severity                   â•‘"
          echo "â•‘  â€¢ Tool execution history with details                       â•‘"
          echo "â•‘  â€¢ Time remaining countdown                                  â•‘"
          echo "â•‘  â€¢ Resource usage analytics (tokens, cost)                   â•‘"
          echo "â•‘  â€¢ Historical data visualization                             â•‘"
          echo "â•‘  â€¢ Export functionality (JSON/CSV)                           â•‘"
          echo "â•‘                                                              â•‘"
          echo "â•‘  MODE: Direct CLIProxyAPI (No LiteLLM)                        â•‘"
          echo "â•‘                                                              â•‘"
          echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo ""
          
      - name: Create Strix Configuration
        id: config
        run: |
          set -euo pipefail
          echo "::group::Creating Strix Configuration (Direct CLIProxyAPI)"
          TIMEFRAME="${{ github.event.inputs.timeframe || env.DEFAULT_TIMEFRAME }}"
          WARNING="${{ github.event.inputs.warning_minutes || env.DEFAULT_WARNING_MINUTES }}"
          SCAN_MODE="${{ github.event.inputs.scan_mode || env.DEFAULT_SCAN_MODE }}"
          MODEL="${{ github.event.inputs.model || 'qwen3-coder-plus' }}"
          ENABLE_STRIXDB="${{ github.event.inputs.enable_strixdb }}"
          [ -z "$ENABLE_STRIXDB" ] && ENABLE_STRIXDB="true"
          
          # White-box and completion mode settings
          WHITEBOX_MODE="${{ github.event.inputs.whitebox_mode || env.DEFAULT_WHITEBOX_MODE }}"
          COMPLETION_MODE="${{ github.event.inputs.completion_mode || env.DEFAULT_COMPLETION_MODE }}"
          TARGET_VULN_COUNT="${{ github.event.inputs.target_vulnerability_count || env.DEFAULT_TARGET_VULN_COUNT }}"
          
          # Adjust scan mode if whitebox is enabled
          if [ "$WHITEBOX_MODE" == "true" ] && [ "$SCAN_MODE" != "whitebox" ]; then
            SCAN_MODE="whitebox"
            echo "White-box mode enabled, overriding scan_mode to 'whitebox'"
          fi
          
          # Create config for direct CLIProxyAPI mode (NO LiteLLM prefix needed)
          for CONFIG_DIR in "$GITHUB_WORKSPACE" "/tmp/strix"; do
            cat > "$CONFIG_DIR/config.json" << CONFIGEOF
          {
            "api": {
              "endpoint": "${{ steps.cliproxy.outputs.endpoint }}",
              "model": "$MODEL"
            },
            "timeframe": {
              "duration_minutes": $TIMEFRAME,
              "warning_minutes": $WARNING,
              "time_awareness_enabled": true
            },
            "dashboard": {
              "enabled": true,
              "web_dashboard_enabled": true,
              "web_dashboard_port": ${{ env.DASHBOARD_PORT }}
            },
            "scan_mode": "$SCAN_MODE",
            "direct_api_mode": true,
            "whitebox": {
              "enabled": $WHITEBOX_MODE,
              "sast_tools": ["semgrep", "bandit", "gosec", "gitleaks", "trufflehog", "trivy", "grype", "bearer", "horusec", "checkov"],
              "secret_detection": true,
              "dependency_scanning": true,
              "iac_scanning": true
            },
            "completion": {
              "mode": "$COMPLETION_MODE",
              "target_vulnerability_count": $TARGET_VULN_COUNT,
              "time_based_enabled": $([ "$COMPLETION_MODE" == "time" ] && echo "true" || echo "false"),
              "vuln_count_based_enabled": $([ "$COMPLETION_MODE" == "vulnerability_count" ] && echo "true" || echo "false")
            }
          }
          CONFIGEOF
          done
          
          echo "Configuration Summary (Direct CLIProxyAPI):"
          echo "  - Endpoint: ${{ steps.cliproxy.outputs.endpoint }}"
          echo "  - Model: $MODEL (Direct, no LiteLLM prefix)"
          echo "  - Duration: $TIMEFRAME minutes"
          echo "  - Warning: $WARNING minutes"
          echo "  - Scan Mode: $SCAN_MODE"
          echo "  - Accounts: ${{ steps.decrypt.outputs.token_count }}"
          echo "  - StrixDB: $ENABLE_STRIXDB"
          echo "  - Dashboard: ${{ steps.tunnel.outputs.dashboard_url || 'local only' }}"
          echo "  - API Mode: Direct HTTP (no LiteLLM)"
          echo "  ----------------------------------------"
          echo "  WHITE-BOX SCANNING:"
          echo "  - White-box Mode: $WHITEBOX_MODE"
          if [ "$WHITEBOX_MODE" == "true" ]; then
            echo "  - SAST Tools: semgrep, bandit, gosec, gitleaks, trufflehog, trivy, grype, bearer, horusec, checkov"
            echo "  - Secret Detection: Enabled"
            echo "  - Dependency Scanning: Enabled"
            echo "  - IaC Scanning: Enabled"
          fi
          echo "  ----------------------------------------"
          echo "  COMPLETION MODE:"
          echo "  - Mode: $COMPLETION_MODE"
          if [ "$COMPLETION_MODE" == "vulnerability_count" ]; then
            echo "  - Target Vulnerability Count: $TARGET_VULN_COUNT"
            echo "  - Time-based: DISABLED (will complete after finding target vulns)"
          else
            echo "  - Time-based: ENABLED (will complete after timeframe)"
          fi
          echo "::endgroup::"
          
      - name: Prepare Instructions
        id: instructions
        run: |
          set -euo pipefail
          INSTRUCTIONS="${{ github.event.inputs.prompt }}"
          
          # Add StrixDB instructions if enabled
          if [ "${{ github.event.inputs.enable_strixdb }}" == "true" ]; then
            INSTRUCTIONS="$INSTRUCTIONS Save useful scripts, tools, exploits, methods to StrixDB."
          fi
          
          # =========================================================================
          # WHITE-BOX SCANNING MODE INSTRUCTIONS
          # =========================================================================
          WHITEBOX_MODE="${{ github.event.inputs.whitebox_mode || env.DEFAULT_WHITEBOX_MODE }}"
          if [ "$WHITEBOX_MODE" == "true" ]; then
            INSTRUCTIONS="$INSTRUCTIONS

          ðŸ”¬ WHITE-BOX SCANNING MODE ACTIVATED - You are now operating in WHITE-BOX scanning mode with FULL SOURCE CODE ACCESS.

          CRITICAL WHITE-BOX INSTRUCTIONS:
          1. You have access to a MASSIVE arsenal of SAST/SCA tools - USE THEM ALL!
          2. Run PARALLEL scans with: semgrep, bandit, gosec, gitleaks, trufflehog, trivy, grype, bearer, horusec
          3. Perform MANUAL code review in addition to automated scanning
          4. Follow data flows from user input to sensitive operations
          5. Check for: hardcoded secrets, SQL injection, XSS, authentication bypasses, authorization flaws
          6. Analyze dependencies for known vulnerabilities (CVEs)
          7. Review IaC files with checkov, terrascan, kics, hadolint
          8. YOU MUST RUN MULTIPLE TOOLS - different tools catch different issues
          9. Validate findings with dynamic testing when possible
          10. Create fixing agents to patch confirmed vulnerabilities

          GITHUB ACTIONS CAPABILITY: You have access to STRIXDB_TOKEN which allows you to:
          - Create GitHub Actions workflows to automate validation
          - Build CI/CD pipelines for security scanning
          - Create reproducible proof-of-concept demonstrations
          - Set up automated testing for exploit validation
          Use this capability wisely for comprehensive security assessment."
          fi
          
          # =========================================================================
          # VULNERABILITY COUNT-BASED SCANNING MODE
          # =========================================================================
          COMPLETION_MODE="${{ github.event.inputs.completion_mode || env.DEFAULT_COMPLETION_MODE }}"
          TARGET_VULN_COUNT="${{ github.event.inputs.target_vulnerability_count || env.DEFAULT_TARGET_VULN_COUNT }}"
          
          if [ "$COMPLETION_MODE" == "vulnerability_count" ]; then
            INSTRUCTIONS="$INSTRUCTIONS

          ðŸŽ¯ VULNERABILITY COUNT-BASED SCANNING MODE ACTIVATED
          
          TARGET: Find exactly $TARGET_VULN_COUNT vulnerabilities before completing the scan.
          
          RULES:
          - You MUST find at least $TARGET_VULN_COUNT confirmed vulnerabilities before calling finish_scan
          - Each vulnerability MUST be validated with a working proof-of-concept
          - Each vulnerability MUST be reported via create_vulnerability_report
          - Time-based completion is DISABLED - focus on finding vulnerabilities, not watching the clock
          - Quality over speed: Ensure each finding is legitimate and exploitable
          - If you reach the target count, you may finish early
          - If time expires before reaching the target, document partial findings
          
          IMPORTANT: The scan will NOT auto-complete based on time. You control when to finish based on vulnerability count."
          else
            INSTRUCTIONS="$INSTRUCTIONS

          â±ï¸ TIME-BASED SCANNING MODE (Default)
          - You MUST use at least 80% of allocated timeframe before finishing
          - Work continuously until time warning is received
          - Do NOT finish early - use ALL available time for thorough testing"
          fi
          
          INSTRUCTIONS="$INSTRUCTIONS Use multi-action mode (up to 7 actions per call) for efficiency. Load-balanced across ${{ steps.decrypt.outputs.token_count }} Qwen accounts via CLIProxyAPI."
          INSTRUCTIONS=$(echo "$INSTRUCTIONS" | sed 's/"/\\"/g' | tr -d '\n')
          echo "instructions=$INSTRUCTIONS" >> "$GITHUB_OUTPUT"
          
          # Export configuration for later steps
          echo "whitebox_mode=$WHITEBOX_MODE" >> "$GITHUB_OUTPUT"
          echo "completion_mode=$COMPLETION_MODE" >> "$GITHUB_OUTPUT"
          echo "target_vuln_count=$TARGET_VULN_COUNT" >> "$GITHUB_OUTPUT"

      - name: Run Strixer Security Scan
        id: strix
        timeout-minutes: ${{ fromJSON(steps.vars.outputs.timeout) }}
        continue-on-error: true
        env:
          STRIXDB_TOKEN: ${{ secrets.STRIXDB_TOKEN }}
          # Remote server configuration
          CRED_TUNNEL: ${{ secrets.CRED_TUNNEL }}
          STRIX_SERVER_TOKEN: ${{ secrets.STRIX_SERVER_TOKEN }}
          STRIX_RUNTIME_BACKEND: ${{ env.STRIX_RUNTIME_BACKEND || 'docker' }}
          # Direct CLIProxyAPI mode - model name without provider prefix
          STRIX_LLM: ${{ github.event.inputs.model || 'qwen3-coder-plus' }}
          LLM_API_BASE: ${{ steps.cliproxy.outputs.endpoint }}
          OPENAI_API_KEY: cliproxy-direct-mode
          OPENAI_API_BASE: ${{ steps.cliproxy.outputs.endpoint }}
          # DIRECT CLIProxyAPI endpoint for HTTP requests
          CLIPROXY_ENDPOINT: ${{ steps.cliproxy.outputs.endpoint }}
          CLIPROXY_MODEL: ${{ github.event.inputs.model || 'qwen3-coder-plus' }}
          # Disable Strix's internal dashboard since we're running an external one
          STRIX_WEB_DASHBOARD: 'false'
          STRIX_DASHBOARD_PORT: ${{ env.DASHBOARD_PORT }}
          # Direct API mode settings
          STRIX_DIRECT_API_MODE: 'true'
          # Rate limiting - optimized for CLIProxyAPI multi-account support
          LLM_RATE_LIMIT_DELAY: '0.1'
          LLM_RATE_LIMIT_CONCURRENT: '3'
          LLM_MAX_REQUESTS_PER_MINUTE: '120'
          # Shared state file for dashboard updates
          STRIX_DASHBOARD_STATE_FILE: /tmp/strix_dashboard_state.json
          # Enable host network mode for Docker container
          STRIX_USE_HOST_NETWORK: 'true'
          # Enable privileged mode for full root access in Docker container
          # This allows apt-get, ping, raw sockets, and other pentest tools to work
          STRIX_PRIVILEGED_MODE: 'true'
          # Minimum time usage percentage before allowing scan to finish
          # Agent must use at least 80% of allocated time before calling finish_scan
          STRIX_MIN_TIME_PERCENT: '80'
          # Timeout settings to prevent tools from hanging indefinitely
          # These prevent the agent from getting stuck on slow/unresponsive operations
          STRIX_TOOL_EXECUTION_TIMEOUT: '60'     # Timeout per tool execution in sandbox (seconds)
          STRIX_SANDBOX_EXECUTION_TIMEOUT: '90'  # Timeout for sandbox HTTP requests (seconds)
          STRIX_BROWSER_NAVIGATION_TIMEOUT: '30' # Browser page navigation timeout (seconds)
          STRIX_BROWSER_OPERATION_TIMEOUT: '45'  # General browser operation timeout (seconds)
          # Pass search API keys if configured
          PERPLEXITY_API_KEY: ${{ secrets.PERPLEXITY_API_KEY }}
          TAVILY_API_KEY: ${{ secrets.TAVILY_API_KEY }}
          SERPAPI_API_KEY: ${{ secrets.SERPAPI_API_KEY }}
          BRAVE_API_KEY: ${{ secrets.BRAVE_API_KEY }}
          GOOGLE_CSE_API_KEY: ${{ secrets.GOOGLE_CSE_API_KEY }}
          GOOGLE_CSE_ID: ${{ secrets.GOOGLE_CSE_ID }}
          # =========================================================================
          # WHITE-BOX SCANNING MODE ENVIRONMENT VARIABLES
          # =========================================================================
          STRIX_WHITEBOX_MODE: ${{ github.event.inputs.whitebox_mode || 'false' }}
          # =========================================================================
          # VULNERABILITY COUNT-BASED COMPLETION MODE
          # =========================================================================
          STRIX_COMPLETION_MODE: ${{ github.event.inputs.completion_mode || 'time' }}
          STRIX_TARGET_VULN_COUNT: ${{ github.event.inputs.target_vulnerability_count || '5' }}
          # =========================================================================
          # GITHUB ACTIONS WORKFLOW CREATION CAPABILITY
          # Agents can use STRIXDB_TOKEN to create workflows for validation/automation
          # =========================================================================
          # Note: STRIXDB_TOKEN is already set above and agents are informed about this
          # capability in the system prompt. They can use it to:
          # - Create validation workflows for discovered vulnerabilities
          # - Set up automated security scanning pipelines
          # - Create proof-of-concept execution workflows
          # - Build helper workflows for testing and validation
        run: |
          set +euo pipefail
          echo "::group::Running Strixer Security Scan (Direct CLIProxyAPI)"
          TARGET="${{ github.event.inputs.target }}"
          TIMEFRAME="${{ github.event.inputs.timeframe || env.DEFAULT_TIMEFRAME }}"
          SCAN_MODE="${{ github.event.inputs.scan_mode || env.DEFAULT_SCAN_MODE }}"
          INSTRUCTIONS="${{ steps.instructions.outputs.instructions }}"
          WHITEBOX_MODE="${{ github.event.inputs.whitebox_mode || 'false' }}"
          COMPLETION_MODE="${{ github.event.inputs.completion_mode || 'time' }}"
          TARGET_VULN_COUNT="${{ github.event.inputs.target_vulnerability_count || '5' }}"
          
          # Override scan mode if whitebox is enabled
          if [ "$WHITEBOX_MODE" == "true" ]; then
            SCAN_MODE="whitebox"
          fi
          
          echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
          echo "â•‘           STRIXER SECURITY SCAN STARTING                     â•‘"
          echo "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£"
          echo "â•‘  Target: $TARGET"
          echo "â•‘  Timeframe: $TIMEFRAME minutes"
          echo "â•‘  Scan Mode: $SCAN_MODE"
          echo "â•‘  Model: ${{ github.event.inputs.model || 'qwen3-coder-plus' }}"
          echo "â•‘  Accounts: ${{ steps.decrypt.outputs.token_count }}"
          echo "â•‘  CLIProxyAPI Endpoint: ${{ steps.cliproxy.outputs.endpoint }}"
          echo "â•‘  API Mode: Direct HTTP (no LiteLLM)"
          echo "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£"
          if [ "$WHITEBOX_MODE" == "true" ]; then
            echo "â•‘  ðŸ”¬ WHITE-BOX MODE: ENABLED                                  â•‘"
            echo "â•‘  - Full source code analysis with SAST tools                â•‘"
            echo "â•‘  - Secret detection enabled                                 â•‘"
            echo "â•‘  - Dependency/SCA scanning enabled                          â•‘"
            echo "â•‘  - IaC scanning enabled                                     â•‘"
          else
            echo "â•‘  ðŸŒ BLACK-BOX MODE: Standard external testing               â•‘"
          fi
          echo "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£"
          if [ "$COMPLETION_MODE" == "vulnerability_count" ]; then
            echo "â•‘  ðŸŽ¯ COMPLETION: Vulnerability Count Based                   â•‘"
            echo "â•‘  - Target: Find $TARGET_VULN_COUNT vulnerabilities                            â•‘"
            echo "â•‘  - Time-based completion: DISABLED                          â•‘"
          else
            echo "â•‘  â±ï¸  COMPLETION: Time Based (Default)                        â•‘"
            echo "â•‘  - Must use 80% of timeframe before finishing               â•‘"
          fi
          echo "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£"
          if [ -n "${{ steps.tunnel.outputs.dashboard_url }}" ]; then
            echo "â•‘  ðŸ“Š Dashboard: ${{ steps.tunnel.outputs.dashboard_url }}"
          fi
          echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          
          # Verify CLIProxyAPI is still running before starting scan
          echo "Verifying CLIProxyAPI status..."
          if ! curl -s "${{ steps.cliproxy.outputs.endpoint }}/models" > /dev/null 2>&1; then
            echo "::warning::CLIProxyAPI may not be responding. Checking logs..."
            cat ~/.cli-proxy-api/cliproxy.log | tail -20 || true
          else
            echo "CLIProxyAPI is responding."
          fi
          
          cd "$GITHUB_WORKSPACE"
          
          # Export dashboard state file path
          export STRIX_DASHBOARD_STATE_FILE="/tmp/strix_dashboard_state.json"
          
          CMD="python -m strix.interface.main --target \"$TARGET\" --scan-mode $SCAN_MODE --non-interactive"
          if [ -n "$INSTRUCTIONS" ]; then
            CMD="$CMD --instruction \"$INSTRUCTIONS\""
          fi
          
          # Run with retry logic
          MAX_RETRIES=2
          RETRY_COUNT=0
          SUCCESS=false
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ] && [ "$SUCCESS" = false ]; do
            echo "Attempt $((RETRY_COUNT + 1)) of $MAX_RETRIES"
            echo "Starting scan at $(date)"
            
            # Run scan with timeout
            timeout ${TIMEFRAME}m bash -c "$CMD" 2>&1 | tee strix_output.log
            EXIT_CODE=${PIPESTATUS[0]}
            
            # Check if it was an API error that we should retry
            if grep -qi "Internal server error\|rate limit\|quota exceeded\|connection reset\|ETIMEDOUT\|ECONNREFUSED" strix_output.log; then
              RETRY_COUNT=$((RETRY_COUNT + 1))
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                echo "API error detected at $(date)"
                echo "Error details from log:"
                grep -i "error\|failed\|exception" strix_output.log | tail -10 || true
                
                # Check CLIProxyAPI status
                echo "Checking CLIProxyAPI status..."
                curl -s "${{ steps.cliproxy.outputs.endpoint }}/models" | jq '.data | length' || echo "CLIProxyAPI not responding!"
                
                # Show recent CLIProxyAPI logs
                echo "Recent CLIProxyAPI logs:"
                tail -30 ~/.cli-proxy-api/cliproxy.log || true
                
                echo "Waiting 15 seconds before retry..."
                sleep 15
                
                # Reduce timeframe for subsequent retries
                REMAINING_TIME=$((TIMEFRAME - 1))
                if [ $REMAINING_TIME -gt 5 ]; then
                  TIMEFRAME=$REMAINING_TIME
                fi
              fi
            else
              SUCCESS=true
            fi
          done
          
          EXIT_CODE=${EXIT_CODE:-1}
          
          # Log the CLIProxyAPI status for debugging
          echo "========================================="
          echo "CLIProxyAPI Status:"
          if [ -f "$HOME/.cli-proxy-api/cliproxy.log" ]; then
            echo "Last 30 lines of CLIProxyAPI log:"
            tail -n 30 "$HOME/.cli-proxy-api/cliproxy.log"
          fi
          echo "========================================="
          
          VULN_COUNT=$(grep -ciE "vulnerability|VULNERABILITY|CVE-|critical|high.*severity" strix_output.log 2>/dev/null || echo "0")
          # Ensure VULN_COUNT is a valid number
          if ! [[ "$VULN_COUNT" =~ ^[0-9]+$ ]]; then
            VULN_COUNT="0"
          fi
          case $EXIT_CODE in
            0)
              echo "Scan completed successfully"
              echo "scan_completed=true" >> "$GITHUB_OUTPUT"
              ;;
            2)
              echo "Scan completed with vulnerabilities found"
              echo "scan_completed=true" >> "$GITHUB_OUTPUT"
              ;;
            124)
              echo "Scan completed (timeframe exhausted)"
              echo "timed_out=true" >> "$GITHUB_OUTPUT"
              echo "scan_completed=true" >> "$GITHUB_OUTPUT"
              ;;
            *)
              echo "Scan completed with exit code: $EXIT_CODE"
              echo "scan_completed=true" >> "$GITHUB_OUTPUT"
              ;;
          esac
          {
            echo "vulnerabilities_found=$VULN_COUNT"
            echo "exit_code=$EXIT_CODE"
          } >> "$GITHUB_OUTPUT"
          echo "::endgroup::"
          exit 0

      - name: Stop Dashboard and Tunnel
        if: always()
        run: |
          set -euo pipefail
          echo "::group::Stopping Dashboard Services"
          
          # Stop tunnel
          if [ -f /tmp/tunnel.pid ]; then
            TUNNEL_PID=$(cat /tmp/tunnel.pid)
            kill $TUNNEL_PID 2>/dev/null || true
            echo "Tunnel stopped (PID: $TUNNEL_PID)"
          fi
          
          # Stop dashboard
          if [ -f /tmp/dashboard.pid ]; then
            DASHBOARD_PID=$(cat /tmp/dashboard.pid)
            kill $DASHBOARD_PID 2>/dev/null || true
            echo "Dashboard stopped (PID: $DASHBOARD_PID)"
          fi
          
          echo "::endgroup::"

      - name: Stop CLIProxyAPI Server
        if: always()
        run: |
          set -euo pipefail
          echo "::group::Stopping CLIProxyAPI"
          AUTH_DIR="$HOME/.cli-proxy-api"
          if [ -f "$AUTH_DIR/cliproxy.pid" ]; then
            PID=$(cat "$AUTH_DIR/cliproxy.pid")
            kill $PID 2>/dev/null || true
            wait $PID 2>/dev/null || true
            echo "CLIProxyAPI stopped (PID: $PID)"
          fi
          if [ -f "$AUTH_DIR/cliproxy.log" ]; then
            echo "=========================================="
            echo "FULL CLIProxyAPI LOGS:"
            echo "=========================================="
            cat "$AUTH_DIR/cliproxy.log"
            echo "=========================================="
          fi
          rm -rf "$AUTH_DIR"/qwen-*.json
          rm -f "$AUTH_DIR/cliproxy.pid"
          echo "::endgroup::"
          
      - name: Upload Scan Results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: strixer-results-${{ github.run_id }}
          path: |
            strix_runs/
            strix_output.log
            config.json
            /tmp/dashboard.log
            /tmp/tunnel.log
            /tmp/strix_dashboard_state.json
            ~/.cli-proxy-api/cliproxy.log
          retention-days: 30

      - name: Create Security Summary
        if: always()
        run: |
          set -euo pipefail
          TIMEFRAME="${{ github.event.inputs.timeframe || env.DEFAULT_TIMEFRAME }}"
          VULNS="${{ steps.strix.outputs.vulnerabilities_found }}"
          TIMED_OUT="${{ steps.strix.outputs.timed_out }}"
          TOKEN_COUNT="${{ steps.decrypt.outputs.token_count }}"
          EXIT_CODE="${{ steps.strix.outputs.exit_code }}"
          SCAN_MODE="${{ github.event.inputs.scan_mode || env.DEFAULT_SCAN_MODE }}"
          MODEL="${{ github.event.inputs.model || 'qwen3-coder-plus' }}"
          TARGET="${{ github.event.inputs.target }}"
          DASHBOARD_URL="${{ steps.tunnel.outputs.dashboard_url }}"
          WHITEBOX_MODE="${{ github.event.inputs.whitebox_mode || 'false' }}"
          COMPLETION_MODE="${{ github.event.inputs.completion_mode || 'time' }}"
          TARGET_VULN_COUNT="${{ github.event.inputs.target_vulnerability_count || '5' }}"
          
          # Override scan mode if whitebox is enabled
          if [ "$WHITEBOX_MODE" == "true" ]; then
            SCAN_MODE="whitebox"
          fi
          
          # Determine status emoji and text
          if [ "$TIMED_OUT" == "true" ]; then
            STATUS_EMOJI="â°"
            STATUS_TEXT="Scan completed (timeframe exhausted)"
          elif [ "$EXIT_CODE" == "0" ]; then
            STATUS_EMOJI="âœ…"
            STATUS_TEXT="Scan completed successfully"
          elif [ "$EXIT_CODE" == "2" ]; then
            STATUS_EMOJI="ðŸ”´"
            STATUS_TEXT="Scan completed with vulnerabilities found"
          else
            STATUS_EMOJI="âš ï¸"
            STATUS_TEXT="Scan completed with exit code: $EXIT_CODE"
          fi
          
          # Create comprehensive summary
          cat > "$GITHUB_STEP_SUMMARY" << SUMMARY_EOF
          # ðŸ¦‰ Strixer Security Scan Dashboard
          
          ## $STATUS_EMOJI Status: $STATUS_TEXT
          
          ---
          
          ### ðŸ“Š Scan Overview
          
          | Property | Value |
          |----------|-------|
          | **Target** | \`$TARGET\` |
          | **Scan Mode** | $SCAN_MODE |
          | **Model** | $MODEL |
          | **Duration** | $TIMEFRAME minutes |
          | **Qwen Accounts** | $TOKEN_COUNT (load-balanced) |
          | **API Mode** | Direct CLIProxyAPI (No LiteLLM) |
          | **Exit Code** | $EXIT_CODE |
          SUMMARY_EOF
          
          # Add White-box mode info
          if [ "$WHITEBOX_MODE" == "true" ]; then
            cat >> "$GITHUB_STEP_SUMMARY" << WHITEBOX_EOF
          
          ### ðŸ”¬ White-Box Scanning Mode
          
          | Feature | Status |
          |---------|--------|
          | **SAST Tools** | âœ… semgrep, bandit, gosec, bearer, horusec |
          | **Secret Detection** | âœ… gitleaks, trufflehog, detect-secrets |
          | **Dependency Scanning** | âœ… trivy, grype, osv-scanner |
          | **IaC Scanning** | âœ… checkov, terrascan, kics, hadolint |
          | **Code Quality** | âœ… eslint, pylint, golangci-lint |
          
          WHITEBOX_EOF
          fi
          
          # Add Completion mode info
          if [ "$COMPLETION_MODE" == "vulnerability_count" ]; then
            cat >> "$GITHUB_STEP_SUMMARY" << VULN_MODE_EOF
          
          ### ðŸŽ¯ Vulnerability Count-Based Completion
          
          | Setting | Value |
          |---------|-------|
          | **Target Count** | $TARGET_VULN_COUNT vulnerabilities |
          | **Time-Based** | Disabled |
          | **Found** | ${VULNS:-0} vulnerabilities |
          
          VULN_MODE_EOF
          else
            cat >> "$GITHUB_STEP_SUMMARY" << TIME_MODE_EOF
          
          ### â±ï¸ Time-Based Completion
          
          | Setting | Value |
          |---------|-------|
          | **Duration** | $TIMEFRAME minutes |
          | **Min Time Usage** | 80% required |
          
          TIME_MODE_EOF
          fi
          
          # Add dashboard info if available
          DASHBOARD_URL="${{ steps.tunnel.outputs.dashboard_url }}"
          if [ -n "$DASHBOARD_URL" ]; then
            cat >> "$GITHUB_STEP_SUMMARY" << DASHEOF
          
          ### ðŸŒ Live Dashboard
          
          **The real-time advanced Next.js dashboard was available at:**
          
          ðŸ”— **[$DASHBOARD_URL]($DASHBOARD_URL)**
          
          > **Click the link above to access the dashboard** (URL is only active during the scan)
          
          **Features Available:**
          - âœ… Real-time agent activity monitoring
          - âœ… **Advanced collaboration network graph** ðŸ†•
          - âœ… Vulnerability discovery tracking
          - âœ… Tool execution history with details
          - âœ… Resource usage analytics (tokens, cost over time)
          - âœ… Multi-agent collaboration view
          - âœ… Export functionality (JSON/CSV)
          - âœ… Historical data visualization
          
          DASHEOF
          fi
          
          cat >> "$GITHUB_STEP_SUMMARY" << FINDINGSEOF
          
          ### ðŸ” Findings
          
          FINDINGSEOF
          
          # Add vulnerability info
          VULN_NUM=${VULNS:-0}
          if [ "$VULN_NUM" -gt "0" ]; then
            echo "**ðŸ”´ Potential Vulnerabilities Detected: $VULN_NUM**" >> "$GITHUB_STEP_SUMMARY"
            echo "" >> "$GITHUB_STEP_SUMMARY"
            echo "> âš ï¸ Review the detailed report in the workflow artifacts for full analysis." >> "$GITHUB_STEP_SUMMARY"
          else
            echo "**ðŸŸ¢ No vulnerabilities detected in this scan.**" >> "$GITHUB_STEP_SUMMARY"
          fi
          
          # Add configuration features
          cat >> "$GITHUB_STEP_SUMMARY" << 'FEATURES_EOF'
          
          ---
          
          ### âš™ï¸ Configuration Features (Strixer)
          
          - âœ… Multi-Action Mode (up to 7 actions/call)
          - âœ… Qwen Token Load Balancing via CLIProxyAPI
          - âœ… **Direct HTTP API Mode (No LiteLLM)**
          - âœ… Automatic Token Refresh (15-minute intervals)
          - âœ… Health Check Enabled
          - âœ… Request Retry (3 attempts)
          - âœ… Real-Time Web Dashboard
          - âœ… Multi-Agent Collaboration
          
          ---
          
          ### ðŸ“¦ Artifacts
          
          Download the **strixer-results** artifact from this workflow run to access:
          - `strix_runs/` - Detailed scan results and reports
          - `strix_output.log` - Complete scan output log
          - `config.json` - Scan configuration
          - `dashboard.log` - Dashboard server logs
          - `tunnel.log` - Tunnel connection logs
          
          ---
          
          *Generated by [Strixer](https://github.com/Hailer367/strix) - Direct CLIProxyAPI Mode | [Discord Community](https://discord.gg/YjKFvEZSdZ)*
          FEATURES_EOF
          
          echo "âœ… Security summary created"

      - name: Comment on PR with Results
        if: github.event_name == 'pull_request' && always()
        uses: actions/github-script@v7
        with:
          script: |
            const timedOut = '${{ steps.strix.outputs.timed_out }}' === 'true';
            const vulnsFound = '${{ steps.strix.outputs.vulnerabilities_found }}' || '0';
            const exitCode = '${{ steps.strix.outputs.exit_code }}';
            const timeframe = '${{ github.event.inputs.timeframe }}' || '${{ env.DEFAULT_TIMEFRAME }}';
            const tokenCount = '${{ steps.decrypt.outputs.token_count }}';
            const dashboardUrl = '${{ steps.tunnel.outputs.dashboard_url }}';
            const model = '${{ github.event.inputs.model }}' || 'qwen3-coder-plus';

            let summary = '## Strixer Security Scan Results\\n\\n';
            if (timedOut) {
              summary += `**Status:** Scan completed (full ${timeframe} minutes used)\\n\\n`;
            } else {
              summary += '**Status:** Scan Completed\\n\\n';
            }
            if (parseInt(vulnsFound) > 0) {
              summary += `**Potential Vulnerabilities:** ${vulnsFound} identified\\n\\n`;
              summary += 'Review the detailed report in workflow artifacts.\\n\\n';
            } else {
              summary += '**No vulnerabilities found**\\n\\n';
            }
            summary += `**Scan Mode:** ${{ github.event.inputs.scan_mode || env.DEFAULT_SCAN_MODE }}\\n`;
            summary += `**Timeframe:** ${timeframe} minutes\\n`;
            summary += `**Model:** ${model}\\n`;
            summary += `**Qwen Accounts:** ${tokenCount} (load-balanced)\\n`;
            summary += `**API Mode:** Direct CLIProxyAPI (No LiteLLM)\\n`;
            summary += `**Exit Code:** ${exitCode}\\n\\n`;
            summary += '### Features:\\n';
            summary += '- Multi-Action Mode (7 actions/call)\\n';
            summary += '- Direct CLIProxyAPI HTTP Integration\\n';
            summary += '- Qwen Token Load Balancing\\n';
            summary += '- Real-Time Web Dashboard\\n';
            summary += '- Multi-Agent Collaboration\\n\\n';
            summary += `[View Full Results](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})\\n`;

            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: summary
            });
